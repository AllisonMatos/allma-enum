"""
WAF Detection â€” Detecta Web Application Firewalls por headers, cookies e body patterns.
"""
import json
import re
from pathlib import Path
from urllib.parse import urlparse
from concurrent.futures import ThreadPoolExecutor, as_completed

from menu import C
from ..output import info, success, warn, error

# ============================================================
# WAF FINGERPRINTS
# ============================================================
WAF_FINGERPRINTS = {
    "Cloudflare": {
        "headers": {"server": ["cloudflare"], "cf-ray": [""]},
        "cookies": ["__cfduid", "cf_clearance", "__cf_bm"],
        "body": [],
    },
    "AWS WAF": {
        "headers": {"x-amzn-requestid": [""], "x-amzn-trace-id": [""]},
        "cookies": ["awsalb", "awsalbcors", "aws-waf-token"],
        "body": ["<html><head><title>403 Forbidden</title></head>"],
    },
    "AWS CloudFront": {
        "headers": {"x-amz-cf-id": [""], "x-amz-cf-pop": [""], "server": ["cloudfront"]},
        "cookies": [],
        "body": [],
    },
    "Akamai": {
        "headers": {"server": ["akamaighost", "akamai"], "x-akamai-transformed": [""]},
        "cookies": ["akamai_generated", "akaalb", "akacd"],
        "body": ["Reference&#32;&#35;"],
    },
    "Sucuri": {
        "headers": {"server": ["sucuri"], "x-sucuri-id": [""], "x-sucuri-cache": [""]},
        "cookies": ["sucuri_cloudproxy"],
        "body": ["Sucuri WebSite Firewall", "Access Denied - Sucuri"],
    },
    "Imperva / Incapsula": {
        "headers": {"x-iinfo": [""], "x-cdn": ["imperva", "incapsula"]},
        "cookies": ["incap_ses", "visid_incap", "nlbi_"],
        "body": ["Incapsula incident", "Powered by Incapsula"],
    },
    "ModSecurity": {
        "headers": {"server": ["mod_security", "modsecurity"]},
        "cookies": [],
        "body": ["ModSecurity", "Mod_Security", "NOYB"],
    },
    "F5 BIG-IP": {
        "headers": {"server": ["big-ip", "bigip"], "x-wa-info": [""]},
        "cookies": ["bigipserver", "f5_cspm", "f5avr", "ts"],
        "body": ["The requested URL was rejected"],
    },
    "Barracuda": {
        "headers": {"server": ["barracuda"]},
        "cookies": ["barra_counter_session", "BNI__BARRACUDA_LB_COOKIE"],
        "body": ["Barracuda Web Application Firewall"],
    },
    "FortiWeb": {
        "headers": {"server": ["fortiweb"]},
        "cookies": ["FORTIWAFSID", "cookiesession1"],
        "body": ["FortiWeb", ".fgd_icon"],
    },
    "Citrix NetScaler": {
        "headers": {"via": ["ns-cache"], "cneonction": [""], "x-client-ip": [""]},
        "cookies": ["citrix_ns_id", "NSC_"],
        "body": ["ns_af_"],
    },
    "DDoS-Guard": {
        "headers": {"server": ["ddos-guard"]},
        "cookies": ["__ddg1", "__ddg2"],
        "body": ["DDoS protection by"],
    },
    "Wordfence": {
        "headers": {},
        "cookies": ["wfwaf-authcookie"],
        "body": ["Generated by Wordfence", "wfBlock", "wordfence"],
    },
    "Fastly": {
        "headers": {"x-fastly-request-id": [""], "via": ["varnish"], "x-served-by": ["cache-"]},
        "cookies": [],
        "body": [],
    },
    "StackPath": {
        "headers": {"x-sp-url": [""], "x-sp-wl": [""]},
        "cookies": [],
        "body": ["StackPath"],
    },
    "Comodo": {
        "headers": {"server": ["comodo"]},
        "cookies": [],
        "body": ["Protected by COMODO"],
    },
    "Wallarm": {
        "headers": {"server": ["nginx-wallarm"]},
        "cookies": [],
        "body": ["Wallarm"],
    },
    "Reblaze": {
        "headers": {"server": ["reblaze"]},
        "cookies": ["rbzid", "rbzid_js"],
        "body": [],
    },
    "CDN77": {
        "headers": {"server": ["cdn77"], "x-cdn77-request-id": [""]},
        "cookies": [],
        "body": [],
    },
    "KeyCDN": {
        "headers": {"server": ["keycdn"], "x-edge-location": [""]},
        "cookies": [],
        "body": [],
    },
}


def ensure_outdir(target: str) -> Path:
    outdir = Path("output") / target / "waf"
    outdir.mkdir(parents=True, exist_ok=True)
    return outdir


def detect_waf(url: str) -> dict | None:
    """Detecta WAF em uma URL."""
    import httpx

    try:
        with httpx.Client(timeout=8, verify=False, follow_redirects=True) as client:
            resp = client.get(url, headers={
                "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
            })

            headers_lower = {k.lower(): v.lower() for k, v in resp.headers.items()}
            cookies = {c.name.lower(): c.value for c in resp.cookies.jar}
            body_lower = resp.text[:5000].lower() if resp.text else ""

            detected = []

            for waf_name, fingerprint in WAF_FINGERPRINTS.items():
                score = 0
                matches = []

                # Check headers
                for h_name, h_patterns in fingerprint.get("headers", {}).items():
                    h_val = headers_lower.get(h_name, "")
                    if h_val:
                        if not h_patterns or h_patterns == [""]:
                            # Header exists = match
                            score += 2
                            matches.append(f"header:{h_name}={h_val[:50]}")
                        else:
                            for p in h_patterns:
                                if p and p in h_val:
                                    score += 3
                                    matches.append(f"header:{h_name}~{p}")

                # Check cookies
                for c_pattern in fingerprint.get("cookies", []):
                    for c_name in cookies:
                        if c_pattern.lower() in c_name:
                            score += 3
                            matches.append(f"cookie:{c_name}")

                # Check body
                for b_pattern in fingerprint.get("body", []):
                    if b_pattern.lower() in body_lower:
                        score += 2
                        matches.append(f"body:~{b_pattern[:30]}")

                if score >= 2:
                    detected.append({
                        "waf": waf_name,
                        "confidence": "high" if score >= 5 else "medium" if score >= 3 else "low",
                        "score": score,
                        "matches": matches,
                    })

            if detected:
                # Ordenar por confianÃ§a
                detected.sort(key=lambda d: d["score"], reverse=True)
                return {
                    "url": str(resp.url),
                    "waf_detected": detected,
                    "primary_waf": detected[0]["waf"],
                    "status": resp.status_code,
                }

    except Exception:
        pass
    return None


def run(context: dict):
    """Executa detecÃ§Ã£o de WAF."""
    target = context.get("target")
    if not target:
        raise ValueError("Target required")

    info(
        f"\nğŸŸªâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ğŸŸª\n"
        f"   ğŸ›¡ï¸ {C.BOLD}{C.CYAN}WAF DETECTION{C.END}\n"
        f"   ğŸ¯ Alvo: {C.GREEN}{target}{C.END}\n"
        f"ğŸŸªâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ğŸŸª\n"
    )

    outdir = ensure_outdir(target)

    urls_file = Path("output") / target / "domain" / "urls_valid.txt"
    if not urls_file.exists():
        warn("âš ï¸ Nenhuma URL vÃ¡lida encontrada.")
        return []

    valid_urls = [l.strip() for l in urls_file.read_text().splitlines() if l.strip()]

    # Deduplicar por base URL
    seen = set()
    unique_urls = []
    for u in valid_urls:
        parsed = urlparse(u)
        base = f"{parsed.scheme}://{parsed.netloc}"
        if base not in seen:
            seen.add(base)
            unique_urls.append(base)

    info(f"   ğŸ“‹ Analisando {len(unique_urls)} hosts para WAF...")

    results = []

    with ThreadPoolExecutor(max_workers=15) as executor:
        futures = {executor.submit(detect_waf, url): url for url in unique_urls}

        for future in as_completed(futures):
            try:
                result = future.result()
                if result:
                    results.append(result)
                    waf = result["primary_waf"]
                    conf = result["waf_detected"][0]["confidence"]
                    conf_color = C.RED if conf == "high" else C.YELLOW
                    info(f"   ğŸ›¡ï¸ {conf_color}[{conf.upper()}]{C.END} {result['url']} â†’ {C.CYAN}{waf}{C.END}")
            except Exception:
                pass

    # Salvar
    output_file = outdir / "waf_results.json"
    output_file.write_text(json.dumps(results, indent=2, ensure_ascii=False))

    if results:
        # Contar WAFs Ãºnicos
        waf_counter = {}
        for r in results:
            waf = r["primary_waf"]
            waf_counter[waf] = waf_counter.get(waf, 0) + 1

        success(f"\n   ğŸ›¡ï¸ WAF detectado em {len(results)}/{len(unique_urls)} hosts!")
        for waf_name, count in sorted(waf_counter.items(), key=lambda x: x[1], reverse=True):
            info(f"   ğŸ“Š {waf_name}: {count} hosts")
        success(f"   ğŸ“‚ Salvos em {output_file}")
    else:
        info("   âœ… Nenhum WAF detectado (ou nÃ£o identificÃ¡vel).")

    no_waf = [u for u in unique_urls if u not in {r["url"] for r in results}]
    if no_waf:
        info(f"   ğŸ¯ {len(no_waf)} hosts SEM WAF detectado (alvos prioritÃ¡rios)")

    return results
